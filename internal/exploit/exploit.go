package exploit

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/olekukonko/tablewriter"
	"github.com/princebabou/fort-go/pkg/models"
)

// AutoExploit automatically attempts to exploit vulnerabilities based on a scan
func AutoExploit(target string, safeMode bool, timeout int, verbose bool) (*models.ExploitResult, error) {
	startTime := time.Now()
	
	if verbose {
		fmt.Printf("Starting automatic exploitation on %s (safe mode: %v)\n", target, safeMode)
	}
	
	// Ensure safe mode is enabled
	if !safeMode {
		return nil, fmt.Errorf("non-safe mode is not allowed")
	}
	
	var vulnerabilities []models.Vulnerability
	successCount := 0
	failCount := 0
	
	// Simulated exploitation for demonstration purposes
	// In a real implementation, actual exploitation would be attempted
	
	// Simulate SQL Injection exploitation
	sqlVuln := models.Vulnerability{
		ID:          "WEB-SQL-INJECTION-EXPLOITED",
		Name:        "SQL Injection Exploited",
		Description: "Successfully demonstrated SQL injection in login form",
		Severity:    models.High,
		Target:      target,
		Location:    "/login",
		Timestamp:   time.Now(),
		Exploitable: true,
		Exploited:   true,
		ExploitInfo: "Payload: ' OR 1=1 -- resulted in authentication bypass",
		Evidence:    "Authentication bypass was achieved without valid credentials",
		Remediation: "Use parameterized queries and input validation",
		References:  []string{"https://owasp.org/www-community/attacks/SQL_Injection"},
	}
	vulnerabilities = append(vulnerabilities, sqlVuln)
	successCount++
	
	// Simulate XSS exploitation
	xssVuln := models.Vulnerability{
		ID:          "WEB-XSS-EXPLOITED",
		Name:        "Cross-Site Scripting (XSS) Exploited",
		Description: "Successfully demonstrated XSS vulnerability in search form",
		Severity:    models.Medium,
		Target:      target,
		Location:    "/search",
		Timestamp:   time.Now(),
		Exploitable: true,
		Exploited:   true,
		ExploitInfo: "Payload: <script>alert('XSS')</script> was reflected in the response",
		Evidence:    "JavaScript alert was executed in the browser context",
		Remediation: "Implement output encoding and Content-Security-Policy",
		References:  []string{"https://owasp.org/www-community/attacks/xss/"},
	}
	vulnerabilities = append(vulnerabilities, xssVuln)
	successCount++
	
	// Simulate failed exploitation attempt
	failedVuln := models.Vulnerability{
		ID:          "WEB-RCE-FAILED",
		Name:        "Remote Code Execution Attempt",
		Description: "Attempted to exploit a potential RCE vulnerability",
		Severity:    models.Critical,
		Target:      target,
		Location:    "/upload",
		Timestamp:   time.Now(),
		Exploitable: false,
		Exploited:   false,
		ExploitInfo: "Attempted to upload a test file but exploitation was unsuccessful",
		Remediation: "Maintain proper file upload validations and restrictions",
	}
	vulnerabilities = append(vulnerabilities, failedVuln)
	failCount++
	
	// Create exploit result
	result := &models.ExploitResult{
		Target:          target,
		ExploitType:     "auto",
		StartTime:       startTime,
		EndTime:         time.Now(),
		Duration:        time.Since(startTime).String(),
		Vulnerabilities: vulnerabilities,
		SuccessCount:    successCount,
		FailCount:       failCount,
		SafeMode:        safeMode,
	}
	
	return result, nil
}

// ManualExploit attempts to exploit a vulnerability with a user-provided payload
func ManualExploit(target, payload string, safeMode bool, timeout int, verbose bool) (*models.ExploitResult, error) {
	startTime := time.Now()
	
	if verbose {
		fmt.Printf("Starting manual exploitation on %s with payload: %s (safe mode: %v)\n", target, payload, safeMode)
	}
	
	// Ensure safe mode is enabled
	if !safeMode {
		return nil, fmt.Errorf("non-safe mode is not allowed")
	}
	
	// Validate the target
	targetURL, err := url.ParseRequestURI(target)
	if err != nil {
		// Try adding http:// prefix if not present
		if !strings.HasPrefix(target, "http") {
			target = "http://" + target
			targetURL, err = url.ParseRequestURI(target)
			if err != nil {
				return nil, fmt.Errorf("invalid target URL: %s", target)
			}
		} else {
			return nil, fmt.Errorf("invalid target URL: %s", target)
		}
	}
	
	var vulnerabilities []models.Vulnerability
	successCount := 0
	failCount := 0
	
	// Determine exploit type based on payload
	exploitType := determineExploitType(payload)
	
	// In a real implementation, this would actually try to exploit the vulnerability
	// Here we just simulate the exploitation process for demonstration
	var exploitResult models.Vulnerability
	success := simulateExploit(targetURL.String(), payload, exploitType, timeout)
	
	if success {
		exploitResult = models.Vulnerability{
			ID:          fmt.Sprintf("%s-EXPLOITED", strings.ToUpper(exploitType)),
			Name:        fmt.Sprintf("%s Exploitation Attempt", exploitType),
			Description: fmt.Sprintf("Successfully demonstrated %s vulnerability", exploitType),
			Severity:    models.High,
			Target:      target,
			Location:    targetURL.Path,
			Timestamp:   time.Now(),
			Exploitable: true,
			Exploited:   true,
			ExploitInfo: fmt.Sprintf("Payload: %s resulted in successful exploitation", payload),
			Evidence:    "Exploitation was successful in safe mode (non-destructive)",
			Remediation: fmt.Sprintf("Apply security patches and implement proper validation for %s attacks", exploitType),
		}
		successCount++
	} else {
		exploitResult = models.Vulnerability{
			ID:          fmt.Sprintf("%s-FAILED", strings.ToUpper(exploitType)),
			Name:        fmt.Sprintf("%s Exploitation Attempt", exploitType),
			Description: fmt.Sprintf("Failed to exploit %s vulnerability", exploitType),
			Severity:    models.Medium,
			Target:      target,
			Location:    targetURL.Path,
			Timestamp:   time.Now(),
			Exploitable: false,
			Exploited:   false,
			ExploitInfo: fmt.Sprintf("Payload: %s did not result in successful exploitation", payload),
		}
		failCount++
	}
	
	vulnerabilities = append(vulnerabilities, exploitResult)
	
	// Create exploit result
	result := &models.ExploitResult{
		Target:          target,
		ExploitType:     "manual",
		StartTime:       startTime,
		EndTime:         time.Now(),
		Duration:        time.Since(startTime).String(),
		Vulnerabilities: vulnerabilities,
		SuccessCount:    successCount,
		FailCount:       failCount,
		SafeMode:        safeMode,
	}
	
	return result, nil
}

// DisplayResults displays the exploitation results
func DisplayResults(result interface{}) {
	exploitResult, ok := result.(*models.ExploitResult)
	if !ok {
		fmt.Println("Invalid result type")
		return
	}
	
	fmt.Println("\n=== Exploitation Results ===")
	fmt.Printf("Target: %s\n", exploitResult.Target)
	fmt.Printf("Exploit Type: %s\n", exploitResult.ExploitType)
	fmt.Printf("Safe Mode: %v\n", exploitResult.SafeMode)
	fmt.Printf("Duration: %s\n", exploitResult.Duration)
	fmt.Printf("Success Count: %d\n", exploitResult.SuccessCount)
	fmt.Printf("Fail Count: %d\n", exploitResult.FailCount)
	
	if len(exploitResult.Vulnerabilities) > 0 {
		fmt.Println("\n=== Exploitation Details ===")
		
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"Status", "Name", "Location", "Details"})
		
		// Define colors
		green := color.New(color.FgGreen).SprintFunc()
		red := color.New(color.FgRed).SprintFunc()
		
		for _, vuln := range exploitResult.Vulnerabilities {
			status := ""
			if vuln.Exploited {
				status = green("SUCCESS")
			} else {
				status = red("FAILED")
			}
			
			table.Append([]string{
				status,
				vuln.Name,
				vuln.Location,
				vuln.ExploitInfo,
			})
		}
		
		table.Render()
	}
}

// SaveResults saves the exploitation results to a file
func SaveResults(result interface{}, outputFile string) error {
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return err
	}
	
	return os.WriteFile(outputFile, data, 0644)
}

// Helper functions
func determineExploitType(payload string) string {
	payload = strings.ToLower(payload)
	
	if strings.Contains(payload, "script") || strings.Contains(payload, "alert") || strings.Contains(payload, "<") {
		return "XSS"
	} else if strings.Contains(payload, "select") || strings.Contains(payload, "union") || strings.Contains(payload, "1=1") {
		return "SQL Injection"
	} else if strings.Contains(payload, "exec") || strings.Contains(payload, "system") || strings.Contains(payload, ";") {
		return "Command Injection"
	} else if strings.Contains(payload, "file") || strings.Contains(payload, "../../") || strings.Contains(payload, "etc/passwd") {
		return "Path Traversal"
	} else {
		return "Generic"
	}
}

func simulateExploit(target, payload, exploitType string, timeout int) bool {
	// In a real implementation, this would actually try to exploit the vulnerability
	// For demonstration purposes, we'll just simulate a success or failure
	
	client := &http.Client{
		Timeout: time.Duration(timeout) * time.Second,
	}
	
	// Make a simple request to ensure the target is reachable
	_, err := client.Get(target)
	if err != nil {
		return false
	}
	
	// Simulate success/failure based on exploit type and payload complexity
	switch exploitType {
	case "SQL Injection":
		return len(payload) > 5
	case "XSS":
		return strings.Contains(payload, "script") && strings.Contains(payload, "alert")
	case "Command Injection":
		return strings.Contains(payload, ";") || strings.Contains(payload, "||")
	case "Path Traversal":
		return strings.Contains(payload, "../")
	default:
		return len(payload) > 10
	}
} 